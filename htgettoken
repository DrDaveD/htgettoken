#!/usr/bin/python3
#
# htgettoken gets OIDC bearer tokens by interacting with Hashicorp vault
#
# Nonstandard python libraries required:
#  m2crypto
#  pyOpenSSL
#  kerberos
#
# This source file is Copyright (c) 2020, FERMI NATIONAL
#   ACCELERATOR LABORATORY.  All rights reserved.
#
# For details of the Fermitools (BSD) license see COPYING
#
# Author: Dave Dykstra dwd@fnal.gov

from __future__ import print_function

prog = "htgettoken"
version = "0.5"

import os
import sys
import socket
import ssl
import string
import json
import re
import shlex
import tempfile
import subprocess
import signal
import time
import secrets
from optparse import OptionParser

try:
    from http import client as http_client
    from urllib import request as urllib_request
    from urllib import parse as urllib_parse
    from urllib.error import HTTPError
    # the following is just a hint for pyinstaller
    from http import cookies as http_cookies
except ImportError: # python < 3
    import httplib as http_client
    import urllib2 as urllib_request
    from urllib2 import HTTPError
    import urlparse as urllib_parse

import kerberos
from M2Crypto import SSL, X509, EVP, RSA, ASN1, m2
from OpenSSL import crypto

# get the default certificates paths for this platform
_paths = ssl.get_default_verify_paths()
_default_cafile = _paths.cafile or ''
if _default_cafile == '':
    # workaround debian bug
    _try_cafile = '/etc/ssl/certs/ca-certificates.crt'
    if os.path.isfile(_try_cafile):
        _default_cafile = _try_cafile
# prefer grid-security default capath
_default_capath = "/etc/grid-security/certificates"
if _paths.capath and not os.path.isdir(_default_capath):
    _default_capath = _paths.capath

defaults = {
    "cafile": _default_cafile,
    "capath": _default_capath,
}

# these are global
options = None
showprogress = False


def usage(parser, msg):
    print(prog + ": " + msg + '\n', file=sys.stderr)
    parser.print_help(sys.stderr)
    sys.exit(2)


def fatal(msg, code=1):
    if (options is None) or not options.quiet:
        if showprogress:
            print()
        print(prog + ": " + msg, file=sys.stderr)
    sys.exit(code)


# print exception type name and contents after fatal error message
def efatal(msg, e, code=1):
    fatal(msg + ': ' + type(e).__name__ + ': ' + str(e), code)



# Make a wrapper so a SSL Connection object can be opened as a file
# this is mostly from
# http://git.ganeti.org/?p=ganeti.git;a=commitdiff;h=beba56ae8;hp=70c815118f7f8bf151044cb09868d1e3d7a63ac8
class _SslSocketWrapper(object):
    def __init__(self, conn):
        self._conn = conn

    def __getattr__(self, name):
        # forward everything to underlying connection
        return getattr(self._conn, name)

    def makefile(self, mode, bufsize=0):
        try:
            return socket.SocketIO(self._conn, mode)
        except AttributeError:  # python < 3
            return socket._fileobject(self._conn, mode, bufsize)

    def close(self):
        # m2crypto always shuts down the SSL connection in the connection
        #  close() function
        ret = self._conn.close()
        if (self._conn.get_shutdown() & 1) != 1:
            print(prog + " program warning: close did not send shutdown", file=sys.stderr)
        return ret

# validate a certificate on an HTTPS connection with M2Crypto
class CertValidatingHTTPSConnection(http_client.HTTPConnection):
    default_port = http_client.HTTPS_PORT
    ssl_timeout = 15

    def __init__(self, host, port=443, key_file=None, cert_file=None,
                 cert_chain_file=None, cafile=None, capath=None, **kwargs):
        http_client.HTTPConnection.__init__(self, host, port, **kwargs)
        self.host = host
        self.port = port
        self.key_file = key_file
        self.cert_file = cert_file
        self.cert_chain_file = cert_chain_file
        self.cafile = cafile
        self.capath = capath

    @classmethod
    def set_timeout(cls, time):
        oldtime = cls.ssl_timeout
        cls.ssl_timeout = time
        return oldtime

    def connect(self):
        # 'sslv23' actually means to accept all, then we turn off
        #   insecure sslv2 & sslv3
        context = SSL.Context('sslv23')
        # many websites say to disable SSL compression for CRIME attack
        #  but unfortunately m2crypto doesn't have a constant for it
        SSL_OP_NO_COMPRESSION = 0x00020000
        context.set_options(m2.SSL_OP_NO_SSLv2 |
                            m2.SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION)
        # the example used for M2Crypto connections was mostly
        #   https://www.heikkitoivonen.net/blog/2008/10/14/ssl-in-python-26/
        if (self.cert_file is not None) or (self.key_file is not None):
            context.load_cert(self.cert_file, self.key_file)
        if self.cert_chain_file is not None:
            context.load_cert_chain(self.cert_chain_file)
        # Note that m2crypto does not verify CRLs.  There is an
        # extension package m2ext that does, but ignoring CRLs for the
        # well-managed servers that cigetcert connects to is deemed to
        # be an acceptable risk.
        context.set_verify(
            SSL.verify_peer | SSL.verify_fail_if_no_peer_cert, depth=9)
        if context.load_verify_locations(self.cafile, self.capath) != 1:
            raise RuntimeError('Could not load verify locations ' +
                               str(self.cafile) + ' ' + str(self.capath))
        # The following cipher list is from "Disable weak ciphers" on
        # https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet
        # combined with the openssl man page at
        # https://www.openssl.org/docs/manmaster/apps/ciphers.html
        # You can see what remains by passing this list to
        #   openssl ciphers -v.
        if context.set_cipher_list('DEFAULT:!eNULL:!aNULL:!ADH:!EXP:!LOW:!MD5:!IDEA:!RC4:@STRENGTH') != 1:
            print("No valid ciphers")
        sslconn = SSL.Connection(context)
        if "settimeout" in dir(SSL.Connection):
            # this improves the error message when it is available
            # from "Operation now in progress" to "timed out"
            sslconn.settimeout(self.ssl_timeout)
        timeout = SSL.timeout(self.ssl_timeout)
        sslconn.set_socket_read_timeout(timeout)
        sslconn.set_socket_write_timeout(timeout)
        sslconn.connect((self.host, self.port))
        self.sock = _SslSocketWrapper(sslconn)

# One API call requires reading the body of a 400 error, so to enable
#  that call VerifiedHTTPSHandler.set_ignore_400() and to disable it
#  call VerifiedHTTPSHandler.clear_ignore_400()
class VerifiedHTTPSHandler(urllib_request.HTTPSHandler):
    ignore_400 = False

    @classmethod
    def set_ignore_400(cls):
        cls.ignore_400 = True

    @classmethod
    def clear_ignore_400(cls):
        cls.ignore_400 = False

    @classmethod
    def is_400_ignored(cls):
        return cls.ignore_400

    def __init__(self, **kwargs):
        urllib_request.HTTPSHandler.__init__(self)
        self._connection_args = kwargs

    def https_open(self, req):
        def http_class_wrapper(netloc, **kwargs):
            full_kwargs = dict(self._connection_args)
            full_kwargs.update(kwargs)
            p = urllib_parse.urlsplit('https://'+netloc)
            return CertValidatingHTTPSConnection(p.hostname, p.port, **full_kwargs)

        return self.do_open(http_class_wrapper, req)

    def http_error_400(self, request, fp, code, msg, hdrs):
        if self.is_400_ignored():
            if options.debug:
                print("ignoring 400 " + msg)
            return fp
        raise HTTPError(request.get_full_url(), code, msg, hdrs, fp)


# function from http://stackoverflow.com/questions/4407539/python-how-to-make-an-option-to-be-required-in-optparse
def checkRequiredOptions(parser):
    missing_options = []
    for option in parser.option_list:
        if (re.search(r'\(required\)$', option.help) and
                eval('options.' + option.dest) is None):
            missing_options.extend(option._long_opts)
    if len(missing_options) > 0:
        usage(parser, "Missing required parameters: " + str(missing_options))


# This is a function because it has to be done after both times
#  the options are processed.
def parseargs(parser, argv):
    global options
    (options, args) = parser.parse_args(argv)
    if len(args) != 0:
        usage(parser, "no non-option arguments expected")

    # This is done here because capath may be needed to retrieve
    #  the options file.
    if options.capath is None:
        options.capath = os.getenv('X509_CERT_DIR') or defaults['capath']


# Read a bearer token from vault
def getBearerToken(opener, vaultserver, vaulttoken, vaultpath):
    if showprogress:
        sys.stdout.write('Attempting to get token from ' + vaultserver +
                         ' ...')
        sys.stdout.flush()
    url = vaultserver + '/v1/' + vaultpath
    params = {'minimum_seconds': options.minsecs}
    if options.scopes is not None:
        params['scopes'] = options.scopes
    if options.audience is not None:
        params['audience'] = options.audience
    url = url + '?' + urllib_parse.urlencode(params)
    if options.debug:
        print("Reading from", url)
    headers = {'X-Vault-Token': vaulttoken}
    request = urllib_request.Request(url=url, headers=headers)
    handle = None
    try:
        handle = opener.open(request)
    except Exception as e:
        if options.debug:
            print("read of token from %s failed: %s" % (url, str(e)))
        if showprogress:
            print(" failed")
        return None
    body = handle.read()
    if options.debug:
        print("##### Begin vault get bearer token response")
        print(body)
        print("##### End vault get bearer token response")
    try:
        response = json.loads(body)
    except Exception as e:
        efatal("decoding response from %s failed" % url, e)
    if 'data' in response and 'access_token' in response['data']:
        if showprogress:
            print(" succeeded")
        return response['data']['access_token']
    if showprogress:
        print(" failed")
    return None


# safely write out a token to where it might be a world-writable
#  directory
def writeTokenSafely(token, outfile):
    # Attempt to remove the file first in case it exists, because os.O_EXCL
    #  requires it to be gone.  Need to use os.O_EXCL to prevent somebody
    #  else from pre-creating the file in order to steal credentials.
    try:
        os.remove(outfile)
    except:
        pass
    try:
        fd, path = tempfile.mkstemp(
            prefix=os.path.dirname(outfile) + '/.' + prog)
        handle = os.fdopen(fd, 'w')
    except Exception as e:
        efatal("failure creating file", e)
    try:
        handle.write(token + '\n')
    except Exception as e:
        efatal("failure writing file", e)
    handle.close()
    try:
        os.rename(path, outfile)
    except Exception as e:
        try:
            os.remove(outfile)
        except:
            pass
        efatal("failure renaming " + path + " to " + outfile, e)
    

### htgettoken main ####
def main():
    global options
    usagestr = "usage: %prog [-h] [otheroptions]"
    parser = OptionParser(usage=usagestr, version=version, prog=prog)

    parser.add_option("-v", "--verbose",
                      action="store_true", default=False,
                      help="write detailed progress to stdout")
    parser.add_option("-d", "--debug",
                      action="store_true", default=False,
                      help="write debug output to stdout (implies -v)")
    parser.add_option("-q", "--quiet",
                      action="store_true", default=False,
                      help="do not print progress or error messages")
    parser.add_option("-s", "--optserver",
                      metavar="HostOrURL",
                      help="server or URL with default %s options" % prog)
    parser.add_option("-a", "--vaultserver",
                      metavar="HostOrURL",
                      help="vault server or URL (required)")
    parser.add_option("-r", "--vaultrole",
                      metavar="rolename",
                      default="default",
                      help="name of vault role for oidc (default \"default\")")
    parser.add_option("-i", "--issuer",
                      metavar="issuername",
                      default="default",
                      help="name of oidc token issuer (default \"default\")")
    parser.add_option("--authpath",
                      metavar="vaultpath",
                      default="auth/oidc-%issuer/oidc",
                      help="path in vault for accessing oidc authentication")
    parser.add_option("--secretpath",
                      metavar="vaultpath",
                      default="secret/oauth-%issuer/creds/%credkey:%role",
                      help="path in vault for accessing bearer token secret")
    parser.add_option("-c", "--configdir",
                      metavar="path",
                      default="~/.config/" + prog,
                      help="path to directory to save config info")
    parser.add_option("--vaulttokenfile",
                      metavar="path",
                      default="/tmp/vt_u%uid",
                      help="path to save vault token")
    parser.add_option("-o", "--outfile",
                      metavar="path",
                      help="path to save bearer token " +
                        "[default: $BEARER_TOKEN_FILE or $XDG_RUNTIME_DIR/bt_u%uid]")
    parser.add_option("--minsecs",
                      type="int", metavar="seconds", default=60,
                      help="minimum number of seconds in bearer token to reuse")
    parser.add_option("--scopes",
                      metavar="scopes",
                      help="comma-separated list of reduced scopes for token")
    parser.add_option("--audience",
                      metavar="audience",
                      help="restricted audience for token")
    parser.add_option("--cafile",
                      metavar="file", default=defaults['cafile'],
                      help="Certifying Authority certificates bundle file")
    parser.add_option("--capath",
                      metavar="path",
                      help="Certifying Authority certificates directory " +
                      '[default: $X509_CERT_DIR or ' +
                      defaults['capath'] + ']')

    # Change the default handler for SIGINT from raising a KeyboardInterrupt
    #  (which is ignored by urllib) to SIG_DFL (which exits)
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    # add default value (if any) to the help messages that are strings
    for option in parser.option_list:
        if (option.default != ("NO", "DEFAULT")) and (option.action == "store"):
            option.help += " [default: %default]"

    # look for default options in the environment
    envopts = os.getenv("HTGETTOKENOPTS", "")
    envargs = shlex.split(envopts, True)

    parseargs(parser, envargs + sys.argv[1:])

    httpshandler = VerifiedHTTPSHandler(
        cafile=options.cafile, capath=options.capath)
    if options.debug:
        httpshandler.set_http_debuglevel(1)
    opener = urllib_request.build_opener(httpshandler)

    if options.optserver is not None:
        # read additional options from optserver
        optserver = options.optserver
        if '://' not in optserver:
            optserver = 'https://' + optserver + '/' + prog + 'opts.txt'
        if options.verbose or options.debug:
            print("Fetching options from " + optserver)
        optrequest = urllib_request.Request(url=optserver)
        opthandle = opener.open(optrequest)
        try:
            opthandle = opener.open(optrequest)
        except Exception as e:
            efatal("fetch of options from %s failed" % optserver, e)
        opts = opthandle.read()
        if isinstance(opts, bytes):
            opts = str(opts.decode('utf-8'))
        opthandle.close()
        if options.debug:
            print("##### Begin additional options")
            print(opts)
            print("##### End additional options")
        try:
            serverargs = shlex.split(opts, True)
        except Exception as e:
            efatal("parsing options from %s failed" % optserver, e)

        parseargs(parser, serverargs + envargs + sys.argv[1:])

    checkRequiredOptions(parser)

    # set implied options
    if options.debug:
        options.verbose = True
    global showprogress
    if not options.quiet and not options.verbose:
        showprogress = True

    # calculate defaults for options that are too complex for "default" keyword
    if options.outfile is None:
        options.outfile = os.getenv("BEARER_TOKEN_FILE")
        if options.outfile is None:
            tmpdir = os.getenv("XDG_RUNTIME_DIR")
            if tmpdir is None:
                tmpdir = '/tmp'
            options.outfile = tmpdir + "/bt_u%uid"
    outfile = options.outfile.replace("%uid", str(os.geteuid()))

    # Get and parse the vaultserver URL
    vaultserver = options.vaultserver
    if '://' not in vaultserver:
        vaultserver = 'https://' + vaultserver
    vaultserverparts = vaultserver.split('/')
    if ':' not in vaultserverparts[2]:
        vaultserver = vaultserver + ':8200'

    # TODO: for optimization, first check to see if a valid token with
    #  same role & scopes already exists and has enough remaining time on it

    secretpath = options.secretpath.replace("%issuer", options.issuer)
    secretpath = secretpath.replace("%role", options.vaultrole)
    vaulttokenfile = options.vaulttokenfile.replace("%uid", str(os.geteuid()))
    vaulttokenfile = os.path.expanduser(vaulttokenfile)
    vaulttoken = None
    bearertoken = None

    # Look for saved credkey, needed for figuring out the vault path
    configfile = options.configdir + '/credkey-' + options.issuer + '-' + options.vaultrole
    configfile = os.path.expanduser(configfile)
    credkey = None
    if not os.path.exists(configfile):
        if options.debug:
            print(configfile, "does not yet exist")
    else:
        if options.debug:
            print("Reading", configfile)
        try:
            with open(configfile, 'r') as file:
                credkey = file.read().strip()
        except Exception as e:
            if options.debug:
                print("Could not read " + configfile + ": " +
                      type(e).__name__ + ": " + str(e), e)
        else:
            if options.verbose:
                print("Credkey from %s: %s" % (configfile, credkey))

            fullsecretpath = secretpath.replace("%credkey", credkey)

            # Check to see if a valid vault token already exists by
            #   attempting to read a bearer token
            if not os.path.exists(vaulttokenfile):
                if options.debug:
                    print(vaulttokenfile, "does not yet exist")
            else:
                if options.debug:
                    print("Reading", vaulttokenfile)
                try:
                    with open(vaulttokenfile, 'r') as file:
                        vaulttoken = file.read().strip()
                except Exception as e:
                    if options.debug:
                        print("Could not load " + vaulttokenfile + ": " +
                              type(e).__name__ + ": " + str(e), e)
                else:
                    if options.verbose:
                        print("Attempting to get bearer token from", vaultserver)
                        print("  using vault token from", vaulttokenfile)

                    bearertoken = getBearerToken(opener, vaultserver,
                                                vaulttoken, fullsecretpath)
                
            if bearertoken is None:
                # Try kerberos authentication with vault
                service = "host@" + vaultserverparts[2].split(':')[0]
                if options.verbose:
                    print("Initializing kerberos client for", service)
                elif showprogress:
                    sys.stdout.write('Attempting kerberos auth with ' + vaultserver +
                                     ' ...')
                    sys.stdout.flush()
                kcontext = None
                try:
                    __, kcontext = kerberos.authGSSClientInit(service=service,
                                        mech_oid=kerberos.GSS_MECH_OID_SPNEGO)
                    kerberos.authGSSClientStep(kcontext, "")
                except Exception as e:
                    kcontext = None
                    if options.verbose:
                        print("Kerberos init failed", e)
                    elif showprogress:
                        print(" failed")

                if kcontext != None:
                    kerberostoken = kerberos.authGSSClientResponse(kcontext)
                    if options.debug:
                        print("Kerberos token:", kerberostoken)

                    url = str(vaultserver) + "/v1/auth/kerberos/login"
                    if options.verbose:
                        print("Negotiating kerberos with vault", url)
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Negotiate ' + kerberostoken
                    }
                    data = ''.encode('ascii')  # empty data is to force a POST
                    request = urllib_request.Request(url=url, headers=headers, data=data)
                    try:
                        handle = opener.open(request)
                    except Exception as e:
                        if showprogress:
                            print(" failed")
                        efatal("Kerberos negotiate with %s failed" % url, e)

                    body = handle.read()
                    if options.debug:
                        print("##### Begin vault kerberos response")
                        print(body)
                        print("##### End vault kerberos response")
                    response = json.loads(body)
                    if 'auth' in response and response['auth'] is not None:
                        if showprogress:
                            print(" succeeded")
                        vaulttoken=response['auth']['client_token']
                        if options.verbose or showprogress:
                            print("Storing vault token in", vaulttokenfile)
                        writeTokenSafely(vaulttoken, vaulttokenfile)

                        if options.verbose:
                            print("Attempting to get bearer token from " + vaultserver)

                        bearertoken = getBearerToken(opener, vaultserver,
                                                    vaulttoken, fullsecretpath)

                    elif options.verbose:
                        print("Kerberos authentication failed")
                        if options.debug:
                            if 'warnings' in response:
                                for warning in response['warnings']:
                                    print("  " + warning)
                            if 'errors' in response:
                                for error in response['errors']:
                                    print("  " + error)
                    elif showprogress:
                        print(" failed")

    if bearertoken is None:
        if options.verbose or showprogress:
            print("Attempting OIDC authentication with", vaultserver)
        authpath = options.authpath.replace("%issuer", options.issuer)
        url = vaultserver + '/v1/' + authpath + '/auth_url'
        nonce = secrets.token_urlsafe()
        authdata = {
            'role': options.vaultrole,
            'client_nonce': nonce,
            'redirect_uri': vaultserver + '/v1/' + authpath + '/callback'
        }
        data = json.dumps(authdata)
        if options.debug:
            print("Authenticating to", url)
            print("##### Begin authentication data")
            print(data)
            print("##### End authentication data")
        request = urllib_request.Request(url=url, data=data.encode())
        handle = None
        try:
            handle = opener.open(request)
        except Exception as e:
            efatal("Initiating authentication to %s failed" % vaultserver, e)
        body = handle.read()
        if options.debug:
            print("##### Begin vault initiate auth response")
            print(body)
            print("##### End vault initiate auth response")
        try:
            response = json.loads(body)
        except Exception as e:
            efatal("decoding response from %s failed" % vaultserver, e)

        if 'data' not in response:
            fatal("no 'data' in response from %s" % vaultserver)
        data = response['data']
        if 'auth_url' not in data:
            fatal("no 'auth_url' in data from %s" % vaultserver)
        auth_url = data['auth_url']
        del data['auth_url'] 

        print()
        print("Complete the authentication via web browser at:")
        print("    " + auth_url)
        if 'user_code' in data:
            print("When prompted, enter code " + data['user_code'])
            del data['user_code']
        print()
         
        # Don't use python's webbrowser library; it tries too many things
        browser = os.getenv("BROWSER")
        if browser is None:
            # Avoid the default command-line browsers in xdg-open,
            #   especially lynx which hangs
            if os.getenv("DISPLAY") is None:
                browser = "no-browser"
            else:
                # list of common gui browsers copied from el7 xdg-open
                browser = "x-www-browser:firefox:seamonkey:mozilla:epiphany:konqueror:chromium-browser:google-chrome"
            if options.debug:
                print("Setting BROWSER=" + browser)
            os.putenv("BROWSER", browser)
        opencmd = 'xdg-open'
        cp = None
        if sys.platform == 'darwin':
            opencmd = 'open'
        try:
            if options.debug:
                print("Running", opencmd, auth_url)
            cp = subprocess.run([opencmd, auth_url], stderr=subprocess.DEVNULL)
        except:
            pass
        if cp is None or cp.returncode != 0:
            print("Couldn't open browser with '%s', please open URL manually" % opencmd)
            print()

        pollinterval = 0
        data['client_nonce'] = nonce
        datastr = ''
        if 'state' in data:
            url = vaultserver + '/v1/' + authpath + '/poll'
            if 'poll_interval' in data:
                pollinterval = int(data['poll_interval'])
                del data['poll_interval']
        else:
            # backward compatibility for old device flow implementation
            url = vaultserver + '/v1/' + authpath + '/device_wait'
            data['role'] = options.vaultrole
        datastr = json.dumps(data)
        if options.debug:
            print("Continuing authentication at", url)
            if datastr != '':
                print("##### Begin continuation data")
                print(datastr)
                print("##### End continuation data")

        response = None
        while True:
            request = urllib_request.Request(url=url, data=datastr.encode())
            handle = None
            try:
                if pollinterval == 0:
                    # backward compatibility for old device flow implementation
                    # increase the timeout for this potentially long response
                    savetimeout = CertValidatingHTTPSConnection.set_timeout(300)
                    handle = opener.open(request)
                    CertValidatingHTTPSConnection.set_timeout(savetimeout)
                else:
                    if options.debug:
                        print("waiting for " + str(pollinterval) + " seconds")
                    time.sleep(pollinterval)
                    if options.debug:
                        print("polling")
                    # The normal "authorized_pending" response comes in
                    #  the body of a 400 Bad Request.  If we let the
                    #  exception go as normal, the handle gets closed and
                    #  we can't read the body, so temporarily block 400 from
                    #  throwing an exception.
                    VerifiedHTTPSHandler.set_ignore_400()
                    handle = opener.open(request)
                    VerifiedHTTPSHandler.clear_ignore_400()
            except Exception as e:
                efatal("Authentication to %s failed" % vaultserver, e)
            body = handle.read()
            if options.debug:
                print("##### Begin vault auth response")
                print(body)
                print("##### End vault auth response")
            try:
                response = json.loads(body)
            except Exception as e:
                efatal("decoding response from %s failed" % vaultserver, e)
            if 'errors' in response:
                errors = response['errors']
                if errors[0] == "slow_down":
                    pollinterval = pollinterval * 2
                elif errors[0] != "authorization_pending":
                    fatal("error in response from %s: %s" % (vaultserver, errors[0]))
                if options.debug:
                    print("authorization pending, trying again")
            else:
                # good reply
                break

        if 'auth' not in response:
            fatal("no 'auth' in response from %s" % vaultserver)
        auth = response['auth']

        if 'client_token' not in auth:
            fatal("no 'client_token' in response from %s" % vaultserver)
        vaulttoken = auth['client_token']
        if options.verbose or showprogress:
            print("Storing vault token in", vaulttokenfile)
        writeTokenSafely(vaulttoken, vaulttokenfile)

        if 'metadata' not in auth:
            fatal("no 'metadata' in response from %s" % vaultserver)
        metadata = auth['metadata']
        if 'credkey' not in metadata:
            fatal("no 'metadata' in response from %s" % vaultserver)
        credkey = metadata['credkey']

        if options.verbose:
            print("Saving credkey to %s: %s" % (configfile, credkey))
        elif showprogress:
            print("Saving credkey to %s" % configfile)
        try:
            os.makedirs(os.path.expanduser(options.configdir), exist_ok=True)
        except Exception as e:
            efatal('error creating %s' % configdir, e)
        try:
            with open(configfile, 'w') as file:
                file.write(credkey + '\n')
        except Exception as e:
            efatal('error writing %s' % configfile, e)

        if 'oauth2_refresh_token' not in metadata:
            fatal("no 'oauth2_refresh_token' in response from %s" % vaultserver)
        refresh_token = metadata['oauth2_refresh_token']
        fullsecretpath = secretpath.replace("%credkey", credkey)

        if options.verbose:
            print("Saving refresh token to %s" % vaultserver)
        elif showprogress:
            sys.stdout.write("Saving refresh token ...")
            sys.stdout.flush()
        url = vaultserver + '/v1/' + fullsecretpath
        headers = {'X-Vault-Token': vaulttoken}
        data = json.dumps({'refresh_token': refresh_token})
        if options.debug:
            print("Refresh token url is", url)
            print("##### Begin refresh token storage data")
            print(data)
            print("##### End refresh token storage data")
        request = urllib_request.Request(url=url, headers=headers, data=data.encode())
        handle = None
        try:
            handle = opener.open(request)
        except Exception as e:
            if showprogress:
                print(" failed")
            efatal("Refresh token storage to %s failed" % vaultserver, e)
        if showprogress:
            print(" done")

        if options.verbose:
            print("Getting bearer token from " + vaultserver)

        bearertoken = getBearerToken(opener, vaultserver,
                                    vaulttoken, fullsecretpath)

        if bearertoken is None:
            fatal("Failure getting token from " + vaultserver)

    # Write bearer token to outfile
    if options.verbose or showprogress:
        print("Storing bearer token in", outfile)
    writeTokenSafely(bearertoken, outfile)


if __name__ == '__main__':
    main()
