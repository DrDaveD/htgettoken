#!/usr/bin/python3
#
# htgettoken gets OIDC bearer tokens by interacting with Hashicorp vault
#
# Nonstandard python libraries required:
#  m2crypto
#  pyOpenSSL
#  kerberos
#  jwt
#
# This source file is Copyright (c) 2020, FERMI NATIONAL
#   ACCELERATOR LABORATORY.  All rights reserved.
#
# For details of the Fermitools (BSD) license see COPYING
#
# Author: Dave Dykstra dwd@fnal.gov

from __future__ import print_function

import os
import sys
import socket
import ssl
import string
import json
import jwt
import re
import shlex
import tempfile
from optparse import OptionParser

try:
    from http import client as http_client
    from urllib import request as urllib_request
    from urllib import parse as urllib_parse
    # the following is just a hint for pyinstaller
    from http import cookies as http_cookies
except ImportError: # python < 3
    import httplib as http_client
    import urllib2 as urllib_request
    import urlparse as urllib_parse

import kerberos
from M2Crypto import SSL, X509, EVP, RSA, ASN1, m2
from OpenSSL import crypto

prog = "htgettoken"
version = "0.1"

# get the default certificates paths for this platform
_default_cafile = '/etc/ssl/certs/ca-certificates.crt'  # debian
_default_capath = "/etc/grid-security/certificates"
_paths = ssl.get_default_verify_paths()
# always prefer python's default cafile
if _paths.cafile:
    _default_cafile = _paths.cafile
# prefer grid-security default capath
if _paths.capath and not os.path.isdir(_default_capath):
    _default_capath = _paths.capath
if not os.path.isfile(_default_cafile or ''):  # use ca-certificates file:
    _default_cafile = "/etc/pki/tls/cert.pem"

defaults = {
    "cafile": _default_cafile,
    "capath": _default_capath,
}

# these are global
options = None
showprogress = False


def usage(parser, msg):
    print(prog + ": " + msg + '\n', file=sys.stderr)
    parser.print_help(sys.stderr)
    sys.exit(2)


def fatal(msg, code=1):
    if (options is None) or not options.quiet:
        if showprogress:
            print()
        print(prog + ": " + msg, file=sys.stderr)
    sys.exit(code)


# print exception type name and contents after fatal error message
def efatal(msg, e, code=1):
    fatal(msg + ': ' + type(e).__name__ + ': ' + str(e), code)



# Make a wrapper so a SSL Connection object can be opened as a file
# this is mostly from
# http://git.ganeti.org/?p=ganeti.git;a=commitdiff;h=beba56ae8;hp=70c815118f7f8bf151044cb09868d1e3d7a63ac8
class _SslSocketWrapper(object):
    def __init__(self, conn):
        self._conn = conn

    def __getattr__(self, name):
        # forward everything to underlying connection
        return getattr(self._conn, name)

    def makefile(self, mode, bufsize=0):
        try:
            return socket.SocketIO(self._conn, mode)
        except AttributeError:  # python < 3
            return socket._fileobject(self._conn, mode, bufsize)

    def close(self):
        # m2crypto always shuts down the SSL connection in the connection
        #  close() function
        ret = self._conn.close()
        if (self._conn.get_shutdown() & 1) != 1:
            print(prog + " program warning: close did not send shutdown", file=sys.stderr)
        return ret

# validate a certificate on an HTTPS connection with M2Crypto
class CertValidatingHTTPSConnection(http_client.HTTPConnection):
    default_port = http_client.HTTPS_PORT

    def __init__(self, host, port=443, key_file=None, cert_file=None,
                 cert_chain_file=None, cafile=None, capath=None, **kwargs):
        http_client.HTTPConnection.__init__(self, host, port, **kwargs)
        self.host = host
        self.port = port
        self.key_file = key_file
        self.cert_file = cert_file
        self.cert_chain_file = cert_chain_file
        self.cafile = cafile
        self.capath = capath

    def connect(self):
        # 'sslv23' actually means to accept all, then we turn off
        #   insecure sslv2 & sslv3
        context = SSL.Context('sslv23')
        # many websites say to disable SSL compression for CRIME attack
        #  but unfortunately m2crypto doesn't have a constant for it
        SSL_OP_NO_COMPRESSION = 0x00020000
        context.set_options(m2.SSL_OP_NO_SSLv2 |
                            m2.SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION)
        # the example used for M2Crypto connections was mostly
        #   https://www.heikkitoivonen.net/blog/2008/10/14/ssl-in-python-26/
        if (self.cert_file is not None) or (self.key_file is not None):
            context.load_cert(self.cert_file, self.key_file)
        if self.cert_chain_file is not None:
            context.load_cert_chain(self.cert_chain_file)
        # Note that m2crypto does not verify CRLs.  There is an
        # extension package m2ext that does, but ignoring CRLs for the
        # well-managed servers that cigetcert connects to is deemed to
        # be an acceptable risk.
        context.set_verify(
            SSL.verify_peer | SSL.verify_fail_if_no_peer_cert, depth=9)
        if context.load_verify_locations(self.cafile, self.capath) != 1:
            raise RuntimeError('Could not load verify locations ' +
                               str(self.cafile) + ' ' + str(self.capath))
        # The following cipher list is from "Disable weak ciphers" on
        # https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet
        # combined with the openssl man page at
        # https://www.openssl.org/docs/manmaster/apps/ciphers.html
        # You can see what remains by passing this list to
        #   openssl ciphers -v.
        if context.set_cipher_list('DEFAULT:!eNULL:!aNULL:!ADH:!EXP:!LOW:!MD5:!IDEA:!RC4:@STRENGTH') != 1:
            print("No valid ciphers")
        sslconn = SSL.Connection(context)
        if "settimeout" in dir(SSL.Connection):
            # this improves the error message when it is available
            # from "Operation now in progress" to "timed out"
            sslconn.settimeout(15)
        timeout = SSL.timeout(15)
        sslconn.set_socket_read_timeout(timeout)
        sslconn.set_socket_write_timeout(timeout)
        sslconn.connect((self.host, self.port))
        self.sock = _SslSocketWrapper(sslconn)

class VerifiedHTTPSHandler(urllib_request.HTTPSHandler):
    def __init__(self, **kwargs):
        urllib_request.HTTPSHandler.__init__(self)
        self._connection_args = kwargs

    def https_open(self, req):
        def http_class_wrapper(netloc, **kwargs):
            full_kwargs = dict(self._connection_args)
            full_kwargs.update(kwargs)
            p = urllib_parse.urlsplit('https://'+netloc)
            return CertValidatingHTTPSConnection(p.hostname, p.port, **full_kwargs)

        return self.do_open(http_class_wrapper, req)

    # also don't raise an exception for 401 Not authorized errors
    def http_error_401(self, request, response, code, msg, hdrs):
        return response


# function from http://stackoverflow.com/questions/4407539/python-how-to-make-an-option-to-be-required-in-optparse
def checkRequiredOptions(parser):
    missing_options = []
    for option in parser.option_list:
        if (re.search(r'\(required\)$', option.help) and
                eval('options.' + option.dest) is None):
            missing_options.extend(option._long_opts)
    if len(missing_options) > 0:
        usage(parser, "Missing required parameters: " + str(missing_options))


# This is a function because it has to be done after both times
#  the options are processed.
def parseargs(parser, argv):
    global options
    (options, args) = parser.parse_args(argv)
    if len(args) != 0:
        usage(parser, "no non-option arguments expected")

    # This is done here because capath may be needed to retrieve
    #  the options file.
    if options.capath is None:
        options.capath = os.getenv('X509_CERT_DIR') or defaults['capath']


# Read a bearer token from vault
def getBearerToken(opener, vaultserver, vaulttoken, vaultpath):
    if showprogress:
        sys.stdout.write('Attempting to get token from ' + vaultserver +
                         ' ...')
        sys.stdout.flush()
    url = vaultserver + '/v1/' + vaultpath
    headers = {'X-Vault-Token': vaulttoken}
    request = urllib_request.Request(url=url, headers=headers)
    handle = None
    try:
        handle = opener.open(request)
    except Exception as e:
        if options.debug:
            print("read of token from %s failed: %s" % (url, str(e)))
        if handle is not None:
            handle.close()
        if showprogress:
            print(" failed")
        return None
    body = handle.read()
    if options.debug:
        print("##### Begin vault get bearer token response")
        print(body)
        print("##### End vault get bearer token response")
    handle.close()
    try:
        response = json.loads(body)
    except Exception as e:
        efatal("decoding response from %s failed" % url, e)
    if 'data' in response and 'access_token' in response['data']:
        if showprogress:
            print(" succeeded")
        return response['data']['access_token']
    if showprogress:
        print(" failed")
    return None


# safely write out a token to where it might be a world-writable
#  directory
def writeTokenSafely(token, outfile):
    # Attempt to remove the file first in case it exists, because os.O_EXCL
    #  requires it to be gone.  Need to use os.O_EXCL to prevent somebody
    #  else from pre-creating the file in order to steal credentials.
    try:
        os.remove(outfile)
    except:
        pass
    try:
        fd, path = tempfile.mkstemp(
            prefix=os.path.dirname(outfile) + '/.' + prog)
        handle = os.fdopen(fd, 'w')
    except Exception as e:
        efatal("failure creating file", e)
    try:
        handle.write(token + '\n')
    except Exception as e:
        efatal("failure writing file", e)
    handle.close()
    try:
        os.rename(path, outfile)
    except Exception as e:
        try:
            os.remove(outfile)
        except:
            pass
        efatal("failure renaming " + path + " to " + outfile, e)
    

### htgettoken main ####
def main():
    global options
    usagestr = "usage: %prog [-h] [otheroptions]"
    parser = OptionParser(usage=usagestr, version=version, prog=prog)

    parser.add_option("-v", "--verbose",
                      action="store_true", default=False,
                      help="write detailed progress to stdout")
    parser.add_option("-d", "--debug",
                      action="store_true", default=False,
                      help="write debug output to stdout (implies -v)")
    parser.add_option("-q", "--quiet",
                      action="store_true", default=False,
                      help="do not print progress or error messages")
    parser.add_option("-s", "--optserver",
                      metavar="HostOrURL",
                      help="server or URL with default %s options" % prog)
    parser.add_option("-a", "--vaultserver",
                      metavar="HostOrURL",
                      help="vault server or URL (required)")
    parser.add_option("-r", "--vaultrole",
                      metavar="rolename",
                      default="default",
                      help="name of vault role for oidc (default \"default\")")
    parser.add_option("-i", "--issuer",
                      metavar="issuername",
                      default="default",
                      help="name of oidc token issuer (default \"default\")")
    parser.add_option("--authpath",
                      metavar="vaultpath",
                      default="auth/oidc-%issuer/role/%role",
                      help="path in vault for accessing oidc authentication")
    parser.add_option("--secretpath",
                      metavar="vaultpath",
                      default="oauth-%issuer/creds/%credkey-%role",
                      help="path in vault for accessing bearer token secret")
    parser.add_option("-c", "--configdir",
                      metavar="path",
                      default="~/.config/" + prog,
                      help="path to directory to save config info")
    parser.add_option("-o", "--outfile",
                      metavar="path",
                      help="path to save bearer token " +
                        "[default: $BEARER_TOKEN_FILE or $XDG_RUNTIME_DIR/bt_u%uid]")
    parser.add_option("--vaulttokenfile",
                      metavar="path",
                      default="/tmp/vt_u%uid",
                      help="path to save vault token")
    parser.add_option("--cafile",
                      metavar="file", default=defaults['cafile'],
                      help="Certifying Authority certificates bundle file")
    parser.add_option("--capath",
                      metavar="path",
                      help="Certifying Authority certificates directory " +
                      '[default: $X509_CERT_DIR or ' +
                      defaults['capath'] + ']')

    # add default value (if any) to the help messages that are strings
    for option in parser.option_list:
        if (option.default != ("NO", "DEFAULT")) and (option.action == "store"):
            option.help += " [default: %default]"

    # look for default options in the environment
    envopts = os.getenv("HTGETTOKENOPTS", "")
    envargs = shlex.split(envopts, True)

    parseargs(parser, envargs + sys.argv[1:])

    httpshandler = VerifiedHTTPSHandler(
        cafile=options.cafile, capath=options.capath)
    if options.debug:
        httpshandler.set_http_debuglevel(1)
    opener = urllib_request.build_opener(httpshandler)

    if options.optserver is not None:
        # read additional options from optserver
        optserver = options.optserver
        if '://' not in optserver:
            optserver = 'https://' + optserver + '/' + prog + 'opts.txt'
        if options.verbose or options.debug:
            print("Fetching options from " + optserver)
        optrequest = urllib_request.Request(url=optserver)
        opthandle = opener.open(optrequest)
        try:
            opthandle = opener.open(optrequest)
        except Exception as e:
            efatal("fetch of options from %s failed" % optserver, e)
        opts = opthandle.read()
        if isinstance(opts, bytes):
            opts = str(opts.decode('utf-8'))
        opthandle.close()
        if options.debug:
            print("##### Begin additional options")
            print(opts)
            print("##### End additional options")
        try:
            serverargs = shlex.split(opts, True)
        except Exception as e:
            efatal("parsing options from %s failed" % optserver, e)

        parseargs(parser, serverargs + envargs + sys.argv[1:])

    checkRequiredOptions(parser)

    # set implied options
    if options.debug:
        options.verbose = True
    global showprogress
    if not options.quiet and not options.verbose:
        showprogress = True

    # calculate defaults for options that are too complex for "default" keyword
    if options.outfile is None:
        options.outfile = os.getenv("BEARER_TOKEN_FILE")
        if options.outfile is None:
            tmpdir = os.getenv("XDG_RUNTIME_DIR")
            if tmpdir is None:
                tmpdir = '/tmp'
            options.outfile = tmpdir + "/bt_u%uid"

    # Check to see if an adequate bearer token already exists
    outfile = options.outfile.replace("%uid", str(os.geteuid()))
    if os.path.exists(outfile):
        try:
            with open(outfile, 'r') as file:
                jwtstr = file.read().strip()
            jwtopts = {'verify_signature': False}
            jwtdict = jwt.decode(jwtstr, options=jwtopts)
        except Exception as e:
            if options.debug:
                print('Could not load ' + outfile + ': ' +
                      type(e).__name__ + ': ' + str(e), e)
        else:
            if options.verbose:
                print("Checking if %s has at least %s seconds left" %
                      (outfile, options.minsecs))
            elif showprogress:
                sys.stdout.write('Checking if ' + outfile +
                                 ' can be reused ...')
                sys.stdout.flush()

                # check remaining seconds here

            if showprogress:
                print(" no")
    else:
        if options.debug:
            print('No existing bearer token in ' + outfile)

    # Get and parse the vaultserver URL
    vaultserver = options.vaultserver
    if '://' not in vaultserver:
        vaultserver = 'https://' + vaultserver
    vaultserverparts = vaultserver.split('/')
    if ':' not in vaultserverparts[2]:
        vaultserver = vaultserver + ':8200'

    # TODO: for optimization, first check to see if a valid token with
    #  same role & scopes already exists and has enough remaining time on it

    secretpath = options.secretpath.replace("%issuer", options.issuer)
    secretpath = secretpath.replace("%role", options.vaultrole)
    vaulttokenfile = options.vaulttokenfile.replace("%uid", str(os.geteuid()))
    vaulttokenfile = os.path.expanduser(vaulttokenfile)
    vaulttoken = None
    bearertoken = None

    # Look for saved credkey, needed for figuring out the vault path
    configfile = options.configdir + '/credkey-' + options.issuer + '-' + options.vaultrole
    configfile = os.path.expanduser(configfile)
    credkey = None
    if not os.path.exists(configfile):
        if options.debug:
            print(configfile + ' does not yet exist')
    else:
        if options.debug:
            print('Reading ' + configfile)
        try:
            with open(configfile, 'r') as file:
                credkey = file.read().strip()
        except:
            if options.debug:
                print('Could not read ' + configfile + ': ' +
                      type(e).__name__ + ': ' + str(e), e)
        else:
            if options.verbose:
                print("Credkey from %s: %s" % (configfile, credkey))

            secretpath = secretpath.replace("%credkey", credkey)

            # Check to see if a valid vault token already exists by
            #   attempting to read a bearer token
            if not os.path.exists(vaulttokenfile):
                if options.debug:
                    print(vaulttokenfile + ' does not yet exist')
            else:
                if options.debug:
                    print('Reading ' + vaulttokenfile)
                try:
                    with open(vaulttokenfile, 'r') as file:
                        vaulttoken = file.read().strip()
                except Exception as e:
                    if options.debug:
                        print('Could not load ' + vaulttokenfile + ': ' +
                              type(e).__name__ + ': ' + str(e), e)
                else:
                    if options.verbose:
                        print("Attempting to get bearer token from " + vaultserver)
                        print("  using vault token from " + vaulttokenfile)

                    bearertoken = getBearerToken(opener, vaultserver,
                                                vaulttoken, secretpath)
                
            if bearertoken is None:
                # Try kerberos authentication with vault
                service = "host@" + vaultserverparts[2].split(':')[0]
                if options.verbose:
                    print('Initializing kerberos client for', service)
                elif showprogress:
                    sys.stdout.write('Attempting kerberos auth with ' + vaultserver +
                                     ' ...')
                    sys.stdout.flush()
                kcontext = None
                try:
                    __, kcontext = kerberos.authGSSClientInit(service=service,
                                        mech_oid=kerberos.GSS_MECH_OID_SPNEGO)
                    kerberos.authGSSClientStep(kcontext, "")
                except Exception as e:
                    kcontext = None
                    if options.verbose:
                        print("Kerberos init failed", e)
                    elif showprogress:
                        print(" failed")

                if kcontext != None:
                    kerberostoken = kerberos.authGSSClientResponse(kcontext)
                    if options.debug:
                        print('Kerberos token:', kerberostoken)

                    url = str(vaultserver) + "/v1/auth/kerberos/login"
                    if options.verbose:
                        print('Negotiating kerberos with vault', url)
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Negotiate ' + kerberostoken
                    }
                    data = ''.encode('ascii')  # empty data is to force a POST
                    request = urllib_request.Request(url=url, headers=headers, data=data)
                    try:
                        handle = opener.open(request)
                    except Exception as e:
                        if showprogress:
                            print(" failed")
                        efatal("Kerberos negotiate with %s failed" % url, e)

                    body = handle.read()
                    if options.debug:
                        print("##### Begin vault kerberos response")
                        print(body)
                        print("##### End vault kerberos response")
                    response = json.loads(body)
                    if 'auth' in response and response['auth'] is not None:
                        if showprogress:
                            print(" succeeded")
                        vaulttoken=response['auth']['client_token']
                        if options.verbose or showprogress:
                            print('Storing vault token in ' + vaulttokenfile)
                        writeTokenSafely(vaulttoken, vaulttokenfile)

                        if options.verbose:
                            print("Attempting to get bearer token from " + vaultserver)

                        bearertoken = getBearerToken(opener, vaultserver,
                                                    vaulttoken, secretpath)

                    elif options.verbose:
                        print('Kerberos authentication failed')
                        if options.debug:
                            if 'warnings' in response:
                                for warning in response['warnings']:
                                    print('  ' + warning)
                            if 'errors' in response:
                                for error in response['errors']:
                                    print('  ' + error)
                    elif showprogress:
                        print(" failed")


    if bearertoken is None:
        print('oidc authentication not yet implemented')
        sys.exit(1)

    # Write bearer token to outfile
    if options.verbose or showprogress:
        print('Storing token in ' + outfile)
    writeTokenSafely(bearertoken, outfile)


if __name__ == '__main__':
    main()
