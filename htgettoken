#!/usr/bin/python3
#
# htgettoken gets OIDC bearer tokens by interacting with Hashicorp vault
#
# Nonstandard python libraries required:
#  m2crypto
#  pyOpenSSL
#  kerberos
#
# This source file is Copyright (c) 2020, FERMI NATIONAL
#   ACCELERATOR LABORATORY.  All rights reserved.
#
# For details of the Fermitools (BSD) license see COPYING
#
# Author: Dave Dykstra dwd@fnal.gov

from __future__ import print_function

prog = "htgettoken"
version = "1.2"

import os
import sys
import socket
import ssl
import string
import json
import re
import shlex
import tempfile
import subprocess
import signal
import time
import secrets
from optparse import OptionParser

try:
    from http import client as http_client
    from urllib import request as urllib_request
    from urllib import parse as urllib_parse
    from urllib.error import HTTPError
    # the following is just a hint for pyinstaller
    from http import cookies as http_cookies
except ImportError: # python < 3
    import httplib as http_client
    import urllib2 as urllib_request
    from urllib2 import HTTPError
    import urlparse as urllib_parse

import kerberos
from M2Crypto import SSL, X509, EVP, RSA, ASN1, m2
from OpenSSL import crypto

# get the default certificates paths for this platform
_paths = ssl.get_default_verify_paths()
_default_cafile = _paths.cafile or ''
if _default_cafile == '':
    # workaround debian bug
    _try_cafile = '/etc/ssl/certs/ca-certificates.crt'
    if os.path.isfile(_try_cafile):
        _default_cafile = _try_cafile
# prefer grid-security default capath
_default_capath = "/etc/grid-security/certificates"
if _paths.capath and not os.path.isdir(_default_capath):
    _default_capath = _paths.capath

defaults = {
    "cafile": _default_cafile,
    "capath": _default_capath,
}

# these are global
options = None
showprogress = False
logfile = sys.stderr

# print wrapper.  print to logfile.
# based on https://stackoverflow.com/a/26286311
def log(*args, **kwargs):
    print(" ".join(map(str,args)), file=logfile, **kwargs)

# send debug output from http_client to the log function
http_client.print = log

# always print to stderr
def logerr(*args, **kwargs):
    print(" ".join(map(str,args)), file=sys.stderr, **kwargs)

def usage(parser, msg):
    logerr(prog + ": " + msg + '\n')
    parser.print_help(sys.stderr)
    sys.exit(2)


def fatal(msg, code=1):
    if (options is None) or not options.quiet:
        if showprogress:
            log()
        logerr(prog + ": " + msg)
    sys.exit(code)

# expand an exception to get maximum info
def expandexception(e):
    typ = type(e).__name__
    msg = typ + ': ' + str(e)
    if typ == 'HTTPError':
        errmsg = e.read().decode()
        try:
            decoded = json.loads(errmsg)
            errmsg = ':'
            if 'errors' in decoded:
                for error in decoded['errors']:
                    errmsg += ' ' + error
            elif 'warnings' in decoded:
                for warning in decoded['warnings']:
                    errmsg += ' ' + warning
            else:
                errmsg = ''
                for key in decoded.keys():
                    errmsg += ', ' + key + ': ' + str(decoded[key])
        except:
            errmsg = ' ' + errmsg
        msg += errmsg
    elif typ == 'GSSError':
        msg = typ + ':'
        for arg in e.args:
            msg += ' ' + arg[0] + '.'
    return msg

# print exception type name and contents after fatal error message
def efatal(msg, e, code=1):
    fatal(msg + ': ' + expandexception(e), code)

# log an exception after given message
def elog(msg, e):
    log(msg + ': ' + expandexception(e))


# Make a wrapper so a SSL Connection object can be opened as a file.
# this is mostly from
# http://git.ganeti.org/?p=ganeti.git;a=commitdiff;h=beba56ae8;hp=70c815118f7f8bf151044cb09868d1e3d7a63ac8
class _SslSocketWrapper(object):
    def __init__(self, conn):
        self._conn = conn

    def __getattr__(self, name):
        # forward everything to underlying connection
        return getattr(self._conn, name)

    def makefile(self, mode, bufsize=0):
        try:
            return socket.SocketIO(self._conn, mode)
        except AttributeError:  # python < 3
            return socket._fileobject(self._conn, mode, bufsize)

    def close(self):
        # m2crypto always shuts down the SSL connection in the connection
        #  close() function
        ret = self._conn.close()
        if (self._conn.get_shutdown() & 1) != 1:
            logerr(prog + " program warning: close did not send shutdown")
        return ret

# Validate a certificate on an HTTPS connection with M2Crypto.
# The primary reason for this is that by default the RHEL7 Python version
#  2.7.5 does not verify host names on https connections.  According to
#   https://access.redhat.com/articles/2039753
# that could however be enabled more simply with
#    ssl._https_verify_certificates()
# although that is a RHEL7-specific feature and may not solve the problem
# everywhere we want to use htgettoken.  Perhaps instead I should just
# depend on always using python3.  If I do switch it to use the standard
# HTTPSConnection class, remember to test what happens with timeouts.
# 
class CertValidatingHTTPSConnection(http_client.HTTPConnection):
    default_port = http_client.HTTPS_PORT
    ssl_timeout = 15

    def __init__(self, host, port, key_file=None, cert_file=None,
                 cert_chain_file=None, cafile=None, capath=None, **kwargs):
        http_client.HTTPConnection.__init__(self, host, port, **kwargs)
        self.host = host
        if port is None:
            self.port = http_client.HTTPS_PORT
        else:
            self.port = port
        self.key_file = key_file
        self.cert_file = cert_file
        self.cert_chain_file = cert_chain_file
        self.cafile = cafile
        self.capath = capath

    @classmethod
    def set_timeout(cls, time):
        oldtime = cls.ssl_timeout
        cls.ssl_timeout = time
        return oldtime

    def connect(self):
        # 'sslv23' actually means to accept all, then we turn off
        #   insecure sslv2 & sslv3
        context = SSL.Context('sslv23')
        # many websites say to disable SSL compression for CRIME attack
        #  but unfortunately m2crypto doesn't have a constant for it
        SSL_OP_NO_COMPRESSION = 0x00020000
        context.set_options(m2.SSL_OP_NO_SSLv2 |
                            m2.SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION)
        # the example used for M2Crypto connections was mostly
        #   https://www.heikkitoivonen.net/blog/2008/10/14/ssl-in-python-26/
        if (self.cert_file is not None) or (self.key_file is not None):
            context.load_cert(self.cert_file, self.key_file)
        if self.cert_chain_file is not None:
            context.load_cert_chain(self.cert_chain_file)
        # Note that m2crypto does not verify CRLs.  There is an
        # extension package m2ext that does, but ignoring CRLs for the
        # well-managed servers that cigetcert connects to is deemed to
        # be an acceptable risk.
        context.set_verify(
            SSL.verify_peer | SSL.verify_fail_if_no_peer_cert, depth=9)
        if context.load_verify_locations(self.cafile, self.capath) != 1:
            raise RuntimeError('Could not load verify locations ' +
                               str(self.cafile) + ' ' + str(self.capath))
        # The following cipher list is from "Disable weak ciphers" on
        # https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet
        # combined with the openssl man page at
        # https://www.openssl.org/docs/manmaster/apps/ciphers.html
        # You can see what remains by passing this list to
        #   openssl ciphers -v.
        if context.set_cipher_list('DEFAULT:!eNULL:!aNULL:!ADH:!EXP:!LOW:!MD5:!IDEA:!RC4:@STRENGTH') != 1:
            fatal("No valid ciphers")
        sslconn = SSL.Connection(context)
        if "settimeout" in dir(SSL.Connection):
            # this improves the error message when it is available
            # from "Operation now in progress" to "timed out"
            sslconn.settimeout(self.ssl_timeout)
        timeout = SSL.timeout(self.ssl_timeout)
        sslconn.set_socket_read_timeout(timeout)
        sslconn.set_socket_write_timeout(timeout)
        sslconn.connect((self.host, self.port))
        self.sock = _SslSocketWrapper(sslconn)

# One API call requires reading the body of a 400 error, so to enable
#  that call VerifiedHTTPSHandler.set_ignore_400() and to disable it
#  call VerifiedHTTPSHandler.clear_ignore_400()
class VerifiedHTTPSHandler(urllib_request.HTTPSHandler):
    ignore_400 = False

    @classmethod
    def set_ignore_400(cls):
        cls.ignore_400 = True

    @classmethod
    def clear_ignore_400(cls):
        cls.ignore_400 = False

    @classmethod
    def is_400_ignored(cls):
        return cls.ignore_400

    def __init__(self, **kwargs):
        urllib_request.HTTPSHandler.__init__(self)
        self._connection_args = kwargs

    def https_open(self, req):
        def http_class_wrapper(netloc, **kwargs):
            full_kwargs = dict(self._connection_args)
            full_kwargs.update(kwargs)
            p = urllib_parse.urlsplit('https://'+netloc)
            return CertValidatingHTTPSConnection(p.hostname, p.port, **full_kwargs)

        return self.do_open(http_class_wrapper, req)

    def http_error_400(self, request, fp, code, msg, hdrs):
        if self.is_400_ignored():
            if options.debug:
                log("ignoring 400 " + msg)
            return fp
        raise HTTPError(request.get_full_url(), code, msg, hdrs, fp)


# function from http://stackoverflow.com/questions/4407539/python-how-to-make-an-option-to-be-required-in-optparse
def checkRequiredOptions(parser):
    missing_options = []
    for option in parser.option_list:
        if (re.search(r'\(required\)$', option.help) and
                eval('options.' + option.dest) is None):
            missing_options.extend(option._long_opts)
    if len(missing_options) > 0:
        usage(parser, "Missing required parameters: " + str(missing_options))


# This is a function because it has to be done after both times
#  the options are processed.
def parseargs(parser, argv):
    global options
    (options, args) = parser.parse_args(argv)
    if len(args) != 0:
        usage(parser, "no non-option arguments expected")

    # This is done here because capath may be needed to retrieve
    #  the options file.
    if options.capath is None:
        options.capath = os.getenv('X509_CERT_DIR') or defaults['capath']


# Either extract the vault token from an auth response or exchange
#  it for another one if the lease_duration is too long
def getVaultToken(opener, vaultserver, vaulttokensecs, response):
    if 'auth' not in response:
        fatal("no 'auth' in response from %s" % vaultserver)
    auth = response['auth']

    if 'client_token' not in auth:
        fatal("no 'client_token' in response from %s" % vaultserver)
    vaulttoken = auth['client_token']

    if 'lease_duration' in auth and int(auth['lease_duration']) <= vaulttokensecs:
        # don't need to exchange, already the correct duration or shorter
        return vaulttoken

    # do a vault token exchange
    url = vaultserver + '/v1/' + 'auth/token/create'
    if options.debug:
        # normally do this quietly; don't want to advertise the exchange
        log("Reading from", url)
    headers = {'X-Vault-Token': vaulttoken}
    data = json.dumps({
        'ttl': options.vaulttokenttl,
        'renewable': 'false',
    })
    request = urllib_request.Request(url=url, headers=headers, data=data.encode())
    handle = None
    try:
        handle = opener.open(request)
    except Exception as e:
        efatal("getting vault token from %s failed" % url, e)
    body = handle.read()
    if options.debug:
        log("##### Begin vault token response")
        log(body)
        log("##### End vault token response")
    try:
        response = json.loads(body)
    except Exception as e:
        efatal("decoding response from %s failed" % url, e)
    if 'auth' in response and 'client_token' in response['auth']:
        return response['auth']['client_token']
    fatal("no vault token in response from %s" % url)

# Read a bearer token from vault
def getBearerToken(opener, vaultserver, vaulttoken, vaultpath):
    if options.showbearerurl:
        print(vaultserver + '/v1/' + vaultpath)
        options.showbearerurl = False
    if options.nobearertoken:
        # no bearer token needed, done
        sys.exit(0)
    if options.verbose:
        log("  at path " + vaultpath)
    elif showprogress:
        log('Attempting to get token from ' + vaultserver + ' ...', end='', flush=True)
    url = vaultserver + '/v1/' + vaultpath
    params = {'minimum_seconds': options.minsecs}
    if options.scopes is not None:
        params['scopes'] = options.scopes
    if options.audience is not None:
        params['audience'] = options.audience
    url = url + '?' + urllib_parse.urlencode(params)
    if options.debug:
        log("Reading from", url)
    headers = {'X-Vault-Token': vaulttoken}
    request = urllib_request.Request(url=url, headers=headers)
    handle = None
    try:
        handle = opener.open(request)
    except Exception as e:
        if options.verbose:
            elog("Read token from %s failed" % url, e)
        elif showprogress:
            log(" failed")
        return None
    body = handle.read()
    if options.debug:
        log("##### Begin vault get bearer token response")
        log(body)
        log("##### End vault get bearer token response")
    try:
        response = json.loads(body)
    except Exception as e:
        efatal("decoding response from %s failed" % url, e)
    if 'data' in response and 'access_token' in response['data']:
        if showprogress:
            log(" succeeded")
        return response['data']['access_token']
    if showprogress:
        log(" failed")
    return None

def isDevFile(file):
    return file.startswith("/dev/std") or file.startswith("/dev/fd")

# safely write out a token to where it might be a world-writable
#  directory, unless the output is a device file
def writeTokenSafely(tokentype, token, outfile):
    dorename = False
    if isDevFile(outfile):
        if options.debug:
            log("Writing", tokentype, "token to", outfile)
        try:
            handle = open(outfile, 'w')
        except Exception as e:
            efatal("failure opening for write", e)
    else:
        if options.verbose or showprogress:
            log("Storing", tokentype, "token in", outfile)
        # Attempt to remove the file first in case it exists, because os.O_EXCL
        #  requires it to be gone.  Need to use os.O_EXCL to prevent somebody
        #  else from pre-creating the file in order to steal credentials.
        try:
            os.remove(outfile)
        except:
            pass
        try:
            fd, path = tempfile.mkstemp(
                prefix=os.path.dirname(outfile) + '/.' + prog)
            handle = os.fdopen(fd, 'w')
        except Exception as e:
            efatal("failure creating file", e)
        dorename = True

    try:
        handle.write(token + '\n')
    except Exception as e:
        efatal("failure writing file", e)
    handle.close()

    if dorename:
        try:
            os.rename(path, outfile)
        except Exception as e:
            try:
                os.remove(outfile)
            except:
                pass
            efatal("failure renaming " + path + " to " + outfile, e)
    

### htgettoken main ####
def main():
    global options
    usagestr = "usage: %prog [-h] [otheroptions]"
    parser = OptionParser(usage=usagestr, version=version, prog=prog)

    parser.add_option("-v", "--verbose",
                      action="store_true", default=False,
                      help="show detailed progress")
    parser.add_option("-d", "--debug",
                      action="store_true", default=False,
                      help="show debug output (implies -v)")
    parser.add_option("-q", "--quiet",
                      action="store_true", default=False,
                      help="do not print progress or error messages")
    parser.add_option("-s", "--optserver",
                      metavar="HostOrURL",
                      help="server or URL with default %s options" % prog)
    parser.add_option("-a", "--vaultserver",
                      metavar="HostOrURL",
                      help="vault server or URL (required)")
    parser.add_option("--vaultalias",
                      metavar="HostOrURL",
                      help="vault alias service name or URL [default same as vaultserver]")
    parser.add_option("-i", "--issuer",
                      metavar="issuername",
                      default="default",
                      help="vault name of oidc token issuer")
    parser.add_option("-r", "--role",
                      metavar="rolename",
                      default="default",
                      help="vault name of role for oidc")
    parser.add_option("--nokerberos",
                      action="store_true", default=False,
                      help="skip attempting to use kerberos authentication")
    parser.add_option("--kerbpath",
                      metavar="vaultpath",
                      default="auth/kerberos-%issuer_%role/login",
                      help="path in vault for accessing kerberos authentication")
    parser.add_option("--kerbprincipal",
                      metavar="principal",
                      help="alternate kerberos principal for kerberos authentication")
    parser.add_option("--nooidc",
                      action="store_true", default=False,
                      help="skip attempting to use oidc authentication")
    parser.add_option("--oidcpath",
                      metavar="vaultpath",
                      default="auth/oidc-%issuer/oidc",
                      help="path in vault for accessing oidc authentication")
    parser.add_option("-c", "--configdir",
                      metavar="path",
                      default="~/.config/" + prog,
                      help="path to directory to save configuration info")
    parser.add_option("--credkey",
                      metavar="key",
                      help="key to use in secretpath [default read from oidc and stored in %configdir/credkey-%issuer-%role]")
    parser.add_option("--secretpath",
                      metavar="vaultpath",
                      default="secret/oauth-%issuer/creds/%credkey:%role",
                      help="path in vault for accessing the bearer token secret")
    parser.add_option("--vaulttokenttl",
                      metavar="time",
                      default="7d",
                      help="time (s, m, h, or d suffix) for new vault token to live")
    parser.add_option("--vaulttokenfile",
                      metavar="path",
                      help="path to save vault token [default /tmp/vt_u%uid if vaulttokenttl less than 1 million seconds, else /dev/stdout]")
    parser.add_option("--vaulttokeninfile",
                      metavar="path",
                      default="%vaulttokenfile",
                      help="path to read vault token from")
    parser.add_option("--showbearerurl",
                      action="store_true", default=False,
                      help="print the bearer URL to stdout")
    parser.add_option("--nobearertoken",
                      action="store_true", default=False,
                      help="only get a vault token, skip getting a bearer token")
    parser.add_option("-o", "--outfile",
                      metavar="path",
                      help="path to save bearer token " +
                        "[default: $BEARER_TOKEN_FILE or $XDG_RUNTIME_DIR/bt_u%uid]")
    parser.add_option("--minsecs",
                      type="int", metavar="seconds", default=60,
                      help="minimum number of seconds in bearer token to reuse")
    parser.add_option("--scopes",
                      metavar="scopes",
                      help="reduced list of scopes for token")
    parser.add_option("--audience",
                      metavar="audience",
                      help="more restricted list of audiences for token")
    parser.add_option("--cafile",
                      metavar="file", default=defaults['cafile'],
                      help="Certifying Authority certificates bundle file")
    parser.add_option("--capath",
                      metavar="path",
                      help="Certifying Authority certificates directory " +
                      '[default: $X509_CERT_DIR or ' +
                      defaults['capath'] + ']')

    # Change the default handler for SIGINT from raising a KeyboardInterrupt
    #  (which is ignored by urllib) to SIG_DFL (which exits)
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    # add default value (if any) to the help messages that are strings
    for option in parser.option_list:
        if (option.default != ("NO", "DEFAULT")) and (option.action == "store"):
            option.help += " [default: %default]"

    # look for default options in the environment
    envopts = os.getenv("HTGETTOKENOPTS", "")
    envargs = shlex.split(envopts, True)

    parseargs(parser, envargs + sys.argv[1:])

    httpshandler = VerifiedHTTPSHandler(
        cafile=options.cafile, capath=options.capath)
    if options.debug:
        httpshandler.set_http_debuglevel(1)
    opener = urllib_request.build_opener(httpshandler)

    if options.optserver is not None:
        # read additional options from optserver
        optserver = options.optserver
        if '://' not in optserver:
            optserver = 'https://' + optserver + '/' + prog + 'opts.txt'
        if options.verbose or options.debug:
            # Note that log messages here will always go to stderr 
            #  because it is too early to easily know if the options
            #  using stdout have been set
            log("Fetching options from " + optserver)
        optrequest = urllib_request.Request(url=optserver)
        try:
            opthandle = opener.open(optrequest)
        except Exception as e:
            efatal("fetch of options from %s failed" % optserver, e)
        opts = opthandle.read()
        if isinstance(opts, bytes):
            opts = str(opts.decode('utf-8'))
        opthandle.close()
        if options.debug:
            log("##### Begin additional options")
            log(opts)
            log("##### End additional options")
        try:
            serverargs = shlex.split(opts, True)
        except Exception as e:
            efatal("parsing options from %s failed" % optserver, e)

        parseargs(parser, serverargs + envargs + sys.argv[1:])

    checkRequiredOptions(parser)

    # set implied options
    if options.debug:
        options.verbose = True
    global showprogress
    if not options.quiet and not options.verbose:
        showprogress = True

    # calculate vault token ttl in seconds
    lastchr = options.vaulttokenttl[-1:]
    numpart = options.vaulttokenttl[0:-1]
    failmsg = "--vaulttokenttl is not a number followed by s, m, h, or d"
    if not numpart.isnumeric():
        fatal(failmsg)
    vaulttokensecs = int(numpart)
    if lastchr == 'd':
        vaulttokensecs *= 24
        # vault only goes up to hours
        options.vaulttokenttl = str(vaulttokensecs) + 'h'
        lastchr = 'h'
    if lastchr == 'h':
        vaulttokensecs *= 60*60
    elif lastchr == 'm':
        vaulttokensecs *= 60
    elif lastchr != 's':
        fatal(failmsg)

    # calculate defaults for options that are too complex for "default" keyword
    if options.outfile is None:
        options.outfile = os.getenv("BEARER_TOKEN_FILE")
        if options.outfile is None:
            tmpdir = os.getenv("XDG_RUNTIME_DIR")
            if tmpdir is None:
                tmpdir = '/tmp'
            options.outfile = tmpdir + "/bt_u%uid"
    outfile = options.outfile.replace("%uid", str(os.geteuid()))

    if options.vaulttokenfile is None:
        if vaulttokensecs > 1000000:
            options.vaulttokenfile = "/dev/stdout"
        else:
            options.vaulttokenfile = "/tmp/vt_u%uid"
    if vaulttokensecs > 1000000 and not isDevFile(options.vaulttokenfile):
        fatal("--vaulttokenfile must be under /dev/ when --vaulttokenttl is greater than a million seconds")

    if options.vaulttokenfile != "/dev/stdout" and not options.showbearerurl:
        # switch log output to stdout if nothing else is using it
        global logfile
        logfile=sys.stdout

    if not options.nooidc and not sys.stdout.isatty() \
                and not sys.stderr.isatty() and not sys.stdin.isatty():
        if options.verbose:
            log("Disabling oidc because running in the background")
        options.nooidc = True

    # Get and parse the vaultserver URL
    vaultserver = options.vaultserver
    if '://' not in vaultserver:
        vaultserver = 'https://' + vaultserver
    vaultserverparts = vaultserver.split('/')
    if ':' not in vaultserverparts[2]:
        vaultserver = vaultserver + ':8200'

    vaultalias = vaultserver
    vaultaliasparts = vaultserverparts
    if options.vaultalias is not None:
        # Similarly parse the vaultalias option
        # This is used when there are multiple servers implementing the
        #   same vault service, and the vaultserver option selects a
        #   specific one.
        vaultalias = options.vaultalias
        if '://' not in vaultalias:
            vaultalias = 'https://' + vaultalias
        vaultaliasparts = vaultalias.split('/')
        if ':' not in vaultaliasparts[2]:
            vaultalias = vaultalias + ':8200'

    secretpath = options.secretpath.replace("%issuer", options.issuer)
    secretpath = secretpath.replace("%role", options.role)
    vaulttokenfile = options.vaulttokenfile.replace("%uid", str(os.geteuid()))
    vaulttokenfile = os.path.expanduser(vaulttokenfile)
    vaulttokeninfile = options.vaulttokeninfile.replace("%vaulttokenfile", options.vaulttokenfile)
    vaulttokeninfile = vaulttokeninfile.replace("%uid", str(os.geteuid()))
    vaulttokeninfile = os.path.expanduser(vaulttokeninfile)
    vaulttoken = None
    bearertoken = None

    credkey = options.credkey
    configfile = None
    if credkey is None:
        # Look for saved credkey, needed for figuring out the vault secretpath
        configfile = options.configdir + '/credkey-' + options.issuer + '-' + options.role
        configfile = os.path.expanduser(configfile)
        if not os.path.exists(configfile):
            if options.debug:
                log(configfile, "does not yet exist")
        else:
            if options.debug:
                log("Reading", configfile)
            try:
                with open(configfile, 'r') as file:
                    credkey = file.read().strip()
            except Exception as e:
                if options.debug:
                    elog("Could not read " + configfile, e)
            else:
                if options.verbose:
                    log("Credkey from %s: %s" % (configfile, credkey))

    if credkey is not None or options.nobearertoken:
        fullsecretpath = ""
        if not options.nobearertoken:
            fullsecretpath = secretpath.replace("%credkey", credkey)

        # Check to see if a valid vault token already exists and works by
        #   attempting to read a bearer token
        if not os.path.exists(vaulttokeninfile):
            if options.debug:
                log(vaulttokeninfile, "does not yet exist")
        else:
            if options.debug:
                log("Reading", vaulttokeninfile)
            try:
                with open(vaulttokeninfile, 'r') as file:
                    vaulttoken = file.read().strip()
            except Exception as e:
                if options.debug:
                    elog("Could not load " + vaulttokeninfile, e)
            else:
                if isDevFile(options.vaulttokeninfile):
                    # The incoming vault token location is coming from /dev,
                    #  so first try to exchange it for one with a duration
                    #  no longer than the requested duration and write that
                    #  out.  This is used to make a vault token with a
                    #  short enough lifetime to limit security risk when
                    #  stored on disk.

                    # construct fake "response" for getVaultToken
                    response = {'auth' : {'client_token': vaulttoken}}
                    vaulttoken = getVaultToken(opener, vaultserver, 
                                                vaulttokensecs, response)
                    writeTokenSafely("vault", vaulttoken, vaulttokenfile)
            
                if options.verbose and not options.nobearertoken:
                    log("Attempting to get bearer token from", vaultserver)
                    log("  using vault token from", vaulttokeninfile)

                bearertoken = getBearerToken(opener, vaultserver,
                                            vaulttoken, fullsecretpath)
            
        if bearertoken is None and not options.nokerberos:
            # Try kerberos authentication with vault
            service = "host@" + vaultaliasparts[2].split(':')[0]
            if options.verbose:
                log("Initializing kerberos client for", service)
            elif showprogress:
                log('Attempting kerberos auth with ' + vaultserver + ' ...', end='', flush=True)
            if os.getenv("KRB5_CONFIG") is None:
                # skip reading from /etc/krb5.conf, it can interfere
                os.putenv("KRB5_CONFIG", "")
            kcontext = None
            try:
                __, kcontext = kerberos.authGSSClientInit(service=service,
                                    mech_oid=kerberos.GSS_MECH_OID_SPNEGO,
                                    principal=options.kerbprincipal)
                kerberos.authGSSClientStep(kcontext, "")
            except Exception as e:
                kcontext = None
                if options.verbose:
                    elog("Kerberos init failed", e)
                elif showprogress:
                    log(" failed")

            if kcontext != None:
                kerberostoken = kerberos.authGSSClientResponse(kcontext)
                if options.debug:
                    log("Kerberos token:", kerberostoken)

                kerbpath = options.kerbpath.replace("%issuer", options.issuer)
                kerbpath = kerbpath.replace("%role", options.role)
                url = str(vaultserver) + "/v1/" + kerbpath
                if options.verbose:
                    log("Negotiating kerberos with", vaultserver)
                    log("  at path " + kerbpath)
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Authorization': 'Negotiate ' + kerberostoken
                }
                data = ''.encode('ascii')  # empty data is to force a POST
                request = urllib_request.Request(url=url, headers=headers, data=data)
                try:
                    handle = opener.open(request)
                except Exception as e:
                    if showprogress:
                        log(" failed")
                    efatal("Kerberos negotiate with %s failed" % url, e)

                body = handle.read()
                if options.debug:
                    log("##### Begin vault kerberos response")
                    log(body)
                    log("##### End vault kerberos response")
                response = json.loads(body)
                if 'auth' in response and response['auth'] is not None:
                    if showprogress:
                        log(" succeeded")
                    vaulttoken = getVaultToken(opener, vaultserver, vaulttokensecs, response)
                    writeTokenSafely("vault", vaulttoken, vaulttokenfile)

                    if options.verbose:
                        log("Attempting to get bearer token from " + vaultserver)

                    bearertoken = getBearerToken(opener, vaultserver,
                                                vaulttoken, fullsecretpath)

                elif options.verbose:
                    log("Kerberos authentication failed")
                    if options.debug:
                        if 'warnings' in response:
                            for warning in response['warnings']:
                                log("  " + warning)
                        if 'errors' in response:
                            for error in response['errors']:
                                log("  " + error)
                elif showprogress:
                    log(" failed")

    if bearertoken is None and not options.nooidc:
        if options.verbose or showprogress:
            log("Attempting OIDC authentication with", vaultserver)
        oidcpath = options.oidcpath.replace("%issuer", options.issuer)
        url = vaultserver + '/v1/' + oidcpath + '/auth_url'
        nonce = secrets.token_urlsafe()
        authdata = {
            'role': options.role,
            'client_nonce': nonce,
            'redirect_uri': vaultalias + '/v1/' + oidcpath + '/callback'
        }
        data = json.dumps(authdata)
        if options.debug:
            log("Authenticating to", url)
            log("##### Begin authentication data")
            log(data)
            log("##### End authentication data")
        request = urllib_request.Request(url=url, data=data.encode())
        handle = None
        try:
            handle = opener.open(request)
        except Exception as e:
            efatal("Initiating authentication to %s failed" % vaultserver, e)
        body = handle.read()
        if options.debug:
            log("##### Begin vault initiate auth response")
            log(body)
            log("##### End vault initiate auth response")
        try:
            response = json.loads(body)
        except Exception as e:
            efatal("decoding response from %s failed" % vaultserver, e)

        if 'data' not in response:
            fatal("no 'data' in response from %s" % vaultserver)
        data = response['data']
        if 'auth_url' not in data:
            fatal("no 'auth_url' in data from %s" % vaultserver)
        auth_url = data['auth_url']
        del data['auth_url'] 
        if auth_url is "":
            fatal("'auth_url' is empty in data from %s" % vaultserver)

        log()
        log("Complete the authentication via web browser at:")
        log("    " + auth_url)
        if 'user_code' in data:
            log("When prompted, enter code " + data['user_code'])
            del data['user_code']
        log()
         
        # Don't use python's webbrowser library; it tries too many things
        browser = os.getenv("BROWSER")
        if browser is None:
            # Avoid the default command-line browsers in xdg-open,
            #   especially lynx which hangs
            if os.getenv("DISPLAY") is None:
                browser = "no-browser"
            else:
                # list of common gui browsers copied from el7 xdg-open
                browser = "x-www-browser:firefox:seamonkey:mozilla:epiphany:konqueror:chromium-browser:google-chrome"
            if options.debug:
                log("Setting BROWSER=" + browser)
            os.putenv("BROWSER", browser)
        opencmd = 'xdg-open'
        cp = None
        if sys.platform == 'darwin':
            opencmd = 'open'
        try:
            if options.debug:
                log("Running", opencmd, auth_url)
            cp = subprocess.run([opencmd, auth_url], stderr=subprocess.DEVNULL)
        except:
            pass
        if cp is None or cp.returncode != 0:
            log("Couldn't open browser with '%s', please open URL manually" % opencmd)
            log()

        pollinterval = 0
        data['client_nonce'] = nonce
        datastr = ''
        if 'state' in data:
            url = vaultserver + '/v1/' + oidcpath + '/poll'
            if 'poll_interval' in data:
                pollinterval = int(data['poll_interval'])
                del data['poll_interval']
        else:
            # backward compatibility for old device flow implementation
            url = vaultserver + '/v1/' + oidcpath + '/device_wait'
            data['role'] = options.role
        datastr = json.dumps(data)
        if options.debug:
            log("Continuing authentication at", url)
            if datastr != '':
                log("##### Begin continuation data")
                log(datastr)
                log("##### End continuation data")

        response = None
        secswaited = 0
        while True:
            request = urllib_request.Request(url=url, data=datastr.encode())
            handle = None
            try:
                if pollinterval == 0:
                    # backward compatibility for old device flow implementation
                    # increase the timeout for this potentially long response
                    savetimeout = CertValidatingHTTPSConnection.set_timeout(300)
                    handle = opener.open(request)
                    CertValidatingHTTPSConnection.set_timeout(savetimeout)
                else:
                    if secswaited > 120:
                        fatal("Polling for response took longer than 2 minutes")
                    if options.debug:
                        log("waiting for " + str(pollinterval) + " seconds")
                    time.sleep(pollinterval)
                    secswaited += pollinterval
                    if options.debug:
                        log("polling")
                    # The normal "authorized_pending" response comes in
                    #  the body of a 400 Bad Request.  If we let the
                    #  exception go as normal, the handle gets closed and
                    #  we can't read the body, so temporarily block 400 from
                    #  throwing an exception.
                    VerifiedHTTPSHandler.set_ignore_400()
                    handle = opener.open(request)
                    VerifiedHTTPSHandler.clear_ignore_400()
            except Exception as e:
                efatal("Authentication to %s failed" % vaultserver, e)
            body = handle.read()
            if options.debug:
                log("##### Begin vault auth response")
                log(body)
                log("##### End vault auth response")
            try:
                response = json.loads(body)
            except Exception as e:
                efatal("decoding response from %s failed" % vaultserver, e)
            if 'errors' in response:
                errors = response['errors']
                if errors[0] == "slow_down":
                    pollinterval = pollinterval * 2
                elif errors[0] != "authorization_pending":
                    fatal("error in response from %s: %s" % (vaultserver, errors[0]))
                if options.debug:
                    log("authorization pending, trying again")
            else:
                # good reply
                break

        vaulttoken = getVaultToken(opener, vaultserver, vaulttokensecs, response)
        writeTokenSafely("vault", vaulttoken, vaulttokenfile)

        auth = response['auth']
        if 'metadata' not in auth:
            fatal("no 'metadata' in response from %s" % vaultserver)
        metadata = auth['metadata']
        if options.credkey is None:
            if 'credkey' not in metadata:
                fatal("no 'metadata' in response from %s" % vaultserver)
            credkey = metadata['credkey']

            if options.verbose:
                log("Saving credkey to %s: %s" % (configfile, credkey))
            elif showprogress:
                log("Saving credkey to %s" % configfile)
            try:
                os.makedirs(os.path.expanduser(options.configdir), exist_ok=True)
            except Exception as e:
                efatal('error creating %s' % configdir, e)
            try:
                with open(configfile, 'w') as file:
                    file.write(credkey + '\n')
            except Exception as e:
                efatal('error writing %s' % configfile, e)

        if 'oauth2_refresh_token' not in metadata:
            fatal("no 'oauth2_refresh_token' in response from %s" % vaultserver)
        refresh_token = metadata['oauth2_refresh_token']
        fullsecretpath = secretpath.replace("%credkey", credkey)

        if options.verbose:
            log("Saving refresh token to " + vaultserver)
            log("  at path " + fullsecretpath)
        elif showprogress:
            log("Saving refresh token ...", end='', flush=True)
        url = vaultserver + '/v1/' + fullsecretpath
        headers = {'X-Vault-Token': vaulttoken}
        data = json.dumps({'refresh_token': refresh_token})
        if options.debug:
            log("Refresh token url is", url)
            log("##### Begin refresh token storage data")
            log(data)
            log("##### End refresh token storage data")
        request = urllib_request.Request(url=url, headers=headers, data=data.encode())
        handle = None
        try:
            handle = opener.open(request)
        except Exception as e:
            if showprogress:
                log(" failed")
            efatal("Refresh token storage to %s failed" % vaultserver, e)
        if showprogress:
            log(" done")

        if options.verbose:
            log("Getting bearer token from " + vaultserver)

        bearertoken = getBearerToken(opener, vaultserver,
                                    vaulttoken, fullsecretpath)

    if bearertoken is None:
        fatal("Failure getting token from " + vaultserver)

    # Write bearer token to outfile
    writeTokenSafely("bearer", bearertoken, outfile)


if __name__ == '__main__':
    main()
